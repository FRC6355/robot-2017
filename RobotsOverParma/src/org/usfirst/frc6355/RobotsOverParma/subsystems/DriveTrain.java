// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc6355.RobotsOverParma.subsystems;

import org.usfirst.frc6355.RobotsOverParma.RobotMap;
import org.usfirst.frc6355.RobotsOverParma.commands.*;

import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.Joystick.AxisType;
import edu.wpi.first.wpilibj.PIDController;
import edu.wpi.first.wpilibj.PIDOutput;
import edu.wpi.first.wpilibj.RobotDrive;
import edu.wpi.first.wpilibj.SpeedController;
import edu.wpi.first.wpilibj.Victor;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

/**
 *
 */
public class DriveTrain extends Subsystem implements PIDOutput {
	// These constants adjust the behavior of the PIDController
	static final double kP = 0.03;	// Proportional
	static final double kI = 0.00;	// Integral
	static final double kD = 0.00;	// Derivative
	static final double kF = 0.00;	// Feed forward
	static final double kToleranceDegrees = 2.0f;

	// Anything lower than this won't turn the wheels.
	static final double kDeadbandForward = 0.4; 
	static final double kDeadbandTurn = 0.4; 

	// The rate of adjustment from the turn controller.
	double rotateToAngleRate = 0.00; 
	
	// A capped value of the turn rate adjustment. Prevents too aggressive correction.
	double rotateToAngleRateCapped = 0.00; 
	
	boolean isDriveStraightMode = false;

	// This PIDController provides feedback on how far off we are from 
	// the desired angle. Used for driving straight or turning to a desired
	// angle.
	static PIDController turnController;

	private final SpeedController leftFrontSpeedControler = RobotMap.driveTrainLeftFrontSpeedControler;
	private final SpeedController leftRearSpeedControler = RobotMap.driveTrainLeftRearSpeedControler;
	private final SpeedController rightFrontSpeedControler = RobotMap.driveTrainRightFrontSpeedControler;
	private final SpeedController rightRearSpeedControler = RobotMap.driveTrainRightRearSpeedControler;
	private final RobotDrive robotDrive4 = RobotMap.driveTrainRobotDrive4;

	public DriveTrain() {
		// Initialize the PIDController.
		// The AHRS (NavX board) is the PIDSource.
		// This DriveTrain class is the PIDOutput target.
		turnController = new PIDController(kP, kI, kD, kF, RobotMap.ahrs, this);
		turnController.setInputRange(-180.0f, 180.0f);
		turnController.setOutputRange(-1.0, 1.0);
		turnController.setAbsoluteTolerance(kToleranceDegrees);
		turnController.setContinuous(true);
		turnController.disable();

	}

	// Put methods for controlling this subsystem
	// here. Call these from Commands.

	public void initDefaultCommand() {
		// Set the default command for a subsystem here.
		// This command is the one that will be active when no other commands
		// require the subsystem.
		setDefaultCommand(new DriveWithJoystickComand());
	}

	/*
	 * This is the primary command for single joystick driving.
	 */
	public void arcadeDrive(Joystick joy) {
		Drive(joy.getAxis(AxisType.kY), joy.getAxis(AxisType.kX));
	}

	/*
	 * Drives the robot forward with the specified magnitude and turn. The
	 * forwardMagnitude is a value between -1 and 1. The turnMagnitude is a
	 * value between -1 and 1. The method will attempt to drive the robot
	 * straight if the turnMagnitude is below 0.1
	 */
	public void Drive(double forwardMagnitude, double turnMagnitude) {
		if (forwardMagnitude < -0.1 || forwardMagnitude > 0.1) {
			double xAxis = turnMagnitude;
			if (-0.1 < xAxis && xAxis < 0.1) {
				if (!isDriveStraightMode) {
					setAngleToCurrentAngle();
				}
				SmartDashboard.putNumber("Robot Drive Correction", rotateToAngleRateCapped);
				SmartDashboard.putBoolean("Robot Drive Correction Active", true);
				robotDrive4.arcadeDrive(handleDeadbandForward(forwardMagnitude),
						handleDeadbandTurn(turnMagnitude + rotateToAngleRateCapped));
			} else {
				SmartDashboard.putBoolean("Robot Drive Correction Active", false);
				robotDrive4.arcadeDrive(handleDeadbandForward(forwardMagnitude), handleDeadbandTurn(turnMagnitude));
				isDriveStraightMode = false;
			}
		} else {
			SmartDashboard.putBoolean("Robot Drive Correction Active", false);
			robotDrive4.arcadeDrive(handleDeadbandForward(forwardMagnitude), handleDeadbandTurn(turnMagnitude));
			isDriveStraightMode = false;
		}
	}

	/*
	 * Stops the drive motion and disables the turn correction.
	 */
	public void Stop() {
		robotDrive4.stopMotor();
		isDriveStraightMode = false;

		// These values will be updated in the pidWrite() method.
		rotateToAngleRate = 0; 
		rotateToAngleRateCapped = 0; 

		turnController.disable();
	}

	/*
	 * Similar to Drive(), this method will cause the robot to turn toward the
	 * desired set angle. The turnMagnitude is a value between -1 and 1.
	 */
	public void TurnToSetpoint(double turnMagnitude) {
		// Calculate the amount to turn.
		// Use the output of the PID controller to help us "ease" into the desired angle.
		double turnRate = turnMagnitude * rotateToAngleRate;

		SmartDashboard.putNumber("Robot Drive Turn Rate", turnRate);
		
		robotDrive4.arcadeDrive(0, handleDeadbandTurn(turnRate));
	}

	/*
	 * Set the target angle for the NavX drive and turn assistance. Sets the
	 * angle to the current angle. Used for driving straight.
	 */
	public void setAngleToCurrentAngle() {
		isDriveStraightMode = true;

		// Acquire current yaw angle, using this as the target angle.
		turnController.reset();
		turnController.setSetpoint(RobotMap.ahrs.getAngle());
		SmartDashboard.putNumber("Robot Drive Angle", RobotMap.ahrs.getAngle());
		
		// These values will be updated in the pidWrite() method.
		rotateToAngleRate = 0; 
		rotateToAngleRateCapped = 0; 
		
		// Enable the PID controller loop so that we get the pidWrite feedback.
		if (!turnController.isEnabled()) {
			turnController.enable();
		}
	}

	/*
	 * Set the target angle for the NavX drive and turn assistance. Sets the
	 * angle to offset degrees from the current angle.
	 */
	public void setAngle(double offset) {
		// Acquire current yaw angle, using this as the target angle.
		turnController.setSetpoint(RobotMap.ahrs.getAngle() + offset);
		
		// These values will be updated in the pidWrite() method.
		rotateToAngleRate = 0; 
		rotateToAngleRateCapped = 0; 
		
		// Enable the PID controller loop so that we get the pidWrite feedback.
		if (!turnController.isEnabled()) {
			turnController.enable();
		}
	}

	/*
	 * Gets the current angle, as reported by the NavX.
	 */
	public double getAngle() {
		return RobotMap.ahrs.getAngle();
	}

	/*
	 * Ensure that we have a minimum amount of power to the drive. Otherwise the
	 * motors won't turn.
	 */
	private double handleDeadbandForward(double value) {
		// Suppress small feeds, like the joystick drift.
		if (Math.abs(value) < 0.1) {
			return 0.0;
		}

		if (value > 0) {
			return Math.max(value, kDeadbandForward);
		} else {
			return Math.min(value, -1 * kDeadbandForward);
		}
	}

	/*
	 * Ensure that we have a minimum amount of power to the drive. Otherwise the
	 * motors won't turn.
	 */
	private double handleDeadbandTurn(double value) {
		// Suppress small feeds, like the joystick drift.
		if (Math.abs(value) < 0.1) {
			return 0.0;
		}

		if (value > 0) {
			return Math.max(value, kDeadbandTurn);
		} else {
			return Math.min(value, -1 * kDeadbandTurn);
		}
	}

	/*
	 * This function is invoked periodically by the PID Controller, based upon
	 * navX MXP yaw angle input and PID Coefficients.
	 */
	@Override
	public void pidWrite(double output) {
		rotateToAngleRate = output;
		rotateToAngleRateCapped = output;

		if (rotateToAngleRateCapped > 0.2) {
			rotateToAngleRateCapped = 0.2;
		} else if (rotateToAngleRateCapped < -0.2) {
			rotateToAngleRateCapped = -0.2;
		}
	}

}
