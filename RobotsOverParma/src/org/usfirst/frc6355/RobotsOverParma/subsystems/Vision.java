// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc6355.RobotsOverParma.subsystems;

import org.usfirst.frc6355.RobotsOverParma.RobotMap;
import org.usfirst.frc6355.RobotsOverParma.commands.*;

import edu.wpi.first.wpilibj.Relay;
import edu.wpi.first.wpilibj.Relay.Value;
import edu.wpi.first.wpilibj.Spark;
import edu.wpi.first.wpilibj.SpeedController;

import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.networktables.NetworkTable;


/**
 * Controls the vision subsystem, which includes
 * a Raspberry PI, a ring light, and a feed of data
 * from a network table.
 */
public class Vision extends Subsystem {
	public static final String kNetworkTableNameGear = "vision/gear";
	public static final String kNetworkTableValueGear_X = "x";
	public static final String kNetworkTableValueGear_Y = "y";
	public static final String kNetworkTableValueGear_Angle = "angle";
	
	public static final double kMinXValue = -120.0; 	// 10'
	public static final double kMaxXValue = 120.0; 		// 10'
	public static final double kMinYValue = -120.0; 	// 10'
	public static final double kMaxYValue = 120.0; 		// 10'

	private NetworkTable table;
    private final Relay visionRingLightRelay = RobotMap.visionRingLightRelay;

	@Override
	protected void initDefaultCommand() {
	}
	
	public void init(){
		table = NetworkTable.getTable(kNetworkTableNameGear);
	}
    
	public void turnRingLightOn(){
		visionRingLightRelay.set(Value.kOn);
	}
	
	public void turnRingLightOff(){
		visionRingLightRelay.set(Value.kOff);
	}
	
	public boolean getIsVisionInRange(){
		if (null == table){
			table = NetworkTable.getTable(kNetworkTableNameGear);
		}
		
		if (null == table){
			System.out.println("Vision not active. Network table not found.");
			return false;
		}
		
		double y = table.getNumber(kNetworkTableValueGear_Y, -1000);
		
		if (y == -1000 || y < 0.0){
			System.out.println("Vision not active. Camera cannot see target.");
			return false;
		}
		
		if (y < kMinYValue || y > kMaxYValue) {
			System.out.println("Vision not active. Values out of range.");
			return false;
		}
		
		if (y < 24.0) {
			System.out.println("Vision not active. Too close.");
			return false; // Stop using vision when less than 2' away.
		}
		
		return true;
	}
	
	public double getVisionXOffset(){
		if (!this.getIsVisionInRange()){
			return 0.0;
		}

		double x = table.getNumber(kNetworkTableValueGear_X, 0.0);
		
		if (x < kMinXValue || x > kMaxXValue)
			return 0.0;
		
		return x;
	}

	public double getVisionYOffset(){
		if (!this.getIsVisionInRange()){
			return 0.0;
		}

		double y = table.getNumber(kNetworkTableValueGear_Y, 0.0);
		
		if (y < kMinYValue || y > kMaxYValue)
			return 0.0;
		
		return y;
	}

	public double getVisionAngleOffset(){
		if (!this.getIsVisionInRange()){
			return 0.0;
		}
		
		double angle = table.getNumber(kNetworkTableValueGear_Angle, 0.0);
		return (angle % 360.0) / 4.0;
	}

}

